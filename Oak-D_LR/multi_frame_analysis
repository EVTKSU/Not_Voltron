#!/usr/bin/env python3

import cv2
import depthai as dai
import numpy as np

# Kalman Filter setup
kalman = cv2.KalmanFilter(4, 2)
kalman.measurementMatrix = np.array([[1,0,0,0],
                                     [0,1,0,0]], np.float32)
kalman.transitionMatrix = np.array([[1,0,1,0],
                                    [0,1,0,1],
                                    [0,0,1,0],
                                    [0,0,0,1]], np.float32)
kalman.processNoiseCov = np.eye(4, dtype=np.float32) * 0.03

# Create pipeline
pipeline = dai.Pipeline()

# Define sources and outputs
camRgb = pipeline.create(dai.node.ColorCamera)
xoutRgb = pipeline.create(dai.node.XLinkOut)

xoutRgb.setStreamName('rgb')

# Properties
camRgb.setPreviewSize(640, 480)
camRgb.setInterleaved(False)
camRgb.setColorOrder(dai.ColorCameraProperties.ColorOrder.BGR)

# Linking
camRgb.preview.link(xoutRgb.input)

# Parameters for temporal smoothing
frame_buffer = []
buffer_size = 5  # Number of frames to average

# Connect to device and start pipeline
with dai.Device(pipeline) as device:
    qRgb = device.getOutputQueue(name="rgb", maxSize=buffer_size, blocking=False)

    while True:
        inRgb = qRgb.get()
        frame = inRgb.getCvFrame()
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        # Apply Canny edge detection
        edges = cv2.Canny(gray, 50, 150)

        # Add edges to buffer
        frame_buffer.append(edges)
        if len(frame_buffer) > buffer_size:
            frame_buffer.pop(0)

        # Temporal smoothing
        avg_edges = np.mean(frame_buffer, axis=0).astype(np.uint8)
        _, avg_edges = cv2.threshold(avg_edges, 50, 255, cv2.THRESH_BINARY)

        # Find edge positions
        edge_positions = np.where(avg_edges > 0)
        if edge_positions[0].size > 0:
            avg_x = np.mean(edge_positions[1])
            avg_y = np.mean(edge_positions[0])

            measured = np.array([[np.float32(avg_x)], [np.float32(avg_y)]])
            kalman.correct(measured)
            prediction = kalman.predict()

            # Draw predicted position
            cv2.circle(frame, (int(prediction[0]), int(prediction[1])), 5, (0, 0, 255), -1)

        # Display the resulting frames
        cv2.imshow('Original Frame', frame)
        cv2.imshow('Smoothed Edges', avg_edges)

        if cv2.waitKey(1) == ord('q'):
            break
